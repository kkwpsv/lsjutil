using Lsj.Util.Win32.BaseTypes;
using Lsj.Util.Win32.Enums;
using Lsj.Util.Win32.Structs;
using System;
using System.Runtime.InteropServices;
using static Lsj.Util.Win32.BaseTypes.BOOL;
using static Lsj.Util.Win32.Constants;
using static Lsj.Util.Win32.Enums.ConsoleModes;
using static Lsj.Util.Win32.Enums.CtrlEventFlags;
using static Lsj.Util.Win32.Enums.ExceptionCodes;
using static Lsj.Util.Win32.Enums.GenericAccessRights;
using static Lsj.Util.Win32.Enums.ProcessCreationFlags;
using static Lsj.Util.Win32.Enums.STARTUPINFOFlags;
using static Lsj.Util.Win32.Enums.SystemErrorCodes;
using static Lsj.Util.Win32.Enums.WindowMessages;
using static Lsj.Util.Win32.Enums.FileShareModes;
using static Lsj.Util.Win32.UnsafePInvokeExtensions;
using static Lsj.Util.Win32.User32;
using Lsj.Util.Win32.Callbacks;

namespace Lsj.Util.Win32
{
    public static partial class Kernel32
    {
        /// <summary>
        /// ATTACH_PARENT_PROCESS
        /// </summary>
        public const uint ATTACH_PARENT_PROCESS = unchecked((uint)-1);

        /// <summary>
        /// CONSOLE_TEXTMODE_BUFFER
        /// </summary>
        public const uint CONSOLE_TEXTMODE_BUFFER = 1;

        /// <summary>
        /// STD_INPUT_HANDLE
        /// </summary>
        public const uint STD_INPUT_HANDLE = unchecked((uint)-10);

        /// <summary>
        /// STD_OUTPUT_HANDLE
        /// </summary>
        public const uint STD_OUTPUT_HANDLE = unchecked((uint)-11);

        /// <summary>
        /// STD_ERROR_HANDLE 
        /// </summary>
        public const uint STD_ERROR_HANDLE = unchecked((uint)-12);


        /// <summary>
        /// <para>
        /// An application-defined function used with the <see cref="SetConsoleCtrlHandler"/> function.
        /// A console process uses this function to handle control signals received by the process.
        /// When the signal is received, the system creates a new thread in the process to execute the function.
        /// The <see cref="PHANDLER_ROUTINE"/> type defines a pointer to this callback function.
        /// HandlerRoutine is a placeholder for the application-defined function name.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/handlerroutine"/>
        /// </para>
        /// </summary>
        /// <param name="dwCtrlType">
        /// The type of control signal received by the handler. This parameter can be one of the following values.
        /// <see cref="CTRL_C_EVENT"/>:
        /// A CTRL+C signal was received, either from keyboard input or from a signal generated by the <see cref="GenerateConsoleCtrlEvent"/> function.
        /// <see cref="CTRL_BREAK_EVENT"/>:
        /// A CTRL+BREAK signal was received, either from keyboard input or from a signal generated by <see cref="GenerateConsoleCtrlEvent"/>.
        /// <see cref="CTRL_CLOSE_EVENT"/>:
        /// A signal that the system sends to all processes attached to a console when the user closes the console
        /// (either by clicking Close on the console window's window menu, or by clicking the End Task button command from Task Manager).
        /// <see cref="CTRL_LOGOFF_EVENT"/>:
        /// A signal that the system sends to all console processes when a user is logging off.
        /// This signal does not indicate which user is logging off, so no assumptions can be made.
        /// Note that this signal is received only by services.
        /// Interactive applications are terminated at logoff, so they are not present when the system sends this signal.
        /// <see cref="CTRL_SHUTDOWN_EVENT"/>:
        /// A signal that the system sends when the system is shutting down.
        /// Interactive applications are not present by the time the system sends this signal,
        /// therefore it can be received only be services in this situation.
        /// Services also have their own notification mechanism for shutdown events.
        /// For more information, see Handler.
        /// This signal can also be generated by an application using <see cref="GenerateConsoleCtrlEvent"/>.
        /// </param>
        /// <returns>
        /// If the function handles the control signal, it should return <see cref="TRUE"/>.
        /// If it returns <see cref="FALSE"/>, the next handler function in the list of handlers for this process is used.
        /// </returns>
        /// <remarks>
        /// Because the system creates a new thread in the process to execute the handler function,
        /// it is possible that the handler function will be terminated by another thread in the process.
        /// Be sure to synchronize threads in the process with the thread for the handler function.
        /// Each console process has its own list of HandlerRoutine functions.
        /// Initially, this list contains only a default handler function that calls <see cref="ExitProcess"/>.
        /// A console process adds or removes additional handler functions by calling the <see cref="SetConsoleCtrlHandler"/> function,
        /// which does not affect the list of handler functions for other processes.
        /// When a console process receives any of the control signals, its handler functions are called on a last-registered,
        /// first-called basis until one of the handlers returns <see cref="TRUE"/>.
        /// If none of the handlers returns <see cref="TRUE"/>, the default handler is called.
        /// The <see cref="CTRL_CLOSE_EVENT"/>, <see cref="CTRL_LOGOFF_EVENT"/>, and <see cref="CTRL_SHUTDOWN_EVENT"/> signals
        /// give the process an opportunity to clean up before termination.
        /// A HandlerRoutine can perform any necessary cleanup, then take one of the following actions:
        /// Call the <see cref="ExitProcess"/> function to terminate the process.
        /// Return <see cref="FALSE"/>. If none of the registered handler functions returns <see cref="TRUE"/>, the default handler terminates the process.
        /// Return <see cref="TRUE"/>. In this case, no other handler functions are called and the system terminates the process.
        /// A process can use the <see cref="SetProcessShutdownParameters"/> function to prevent the system from displaying a dialog box
        /// to the user during logoff or shutdown.
        /// In this case, the system terminates the process when HandlerRoutine returns <see cref="TRUE"/> or when the time-out period elapses.
        /// When a console application is run as a service, it receives a modified default console control handler.
        /// This modified handler does not call <see cref="ExitProcess"/>
        /// when processing the <see cref="CTRL_LOGOFF_EVENT"/> and <see cref="CTRL_SHUTDOWN_EVENT"/> signals.
        /// This allows the service to continue running after the user logs off.
        /// If the service installs its own console control handler, this handler is called before the default handler.
        /// If the installed handler calls <see cref="ExitProcess"/> when processing the <see cref="CTRL_LOGOFF_EVENT"/> signal,
        /// the service exits when the user logs off.
        /// Note that a third-party library or DLL can install a console control handler for your application.
        /// If it does, this handler overrides the default handler, and can cause the application to exit when the user logs off.
        /// </remarks>
        public delegate BOOL Phandlerroutine([In] CtrlEvents dwCtrlType);


        /// <summary>
        /// <para>
        /// Allocates a new console for the calling process.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/allocconsole"/>
        /// </para>
        /// </summary>
        /// <returns>
        /// If the function succeeds, the return value is <see langword="true"/>.
        /// If the function fails, the return value is <see langword="false"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A process can be associated with only one console,
        /// so the <see cref="AllocConsole"/> function fails if the calling process already has a console.
        /// A process can use the <see cref="FreeConsole"/> function to detach itself from its current console,
        /// then it can call <see cref="AllocConsole"/> to create a new console or <see cref="AttachConsole"/> to attach to another console.
        /// If the calling process creates a child process, the child inherits the new console.
        /// <see cref="AllocConsole"/> initializes standard input, standard output, and standard error handles for the new console.
        /// The standard input handle is a handle to the console's input buffer,
        /// and the standard output and standard error handles are handles to the console's screen buffer.To retrieve these handles,
        /// use the <see cref="GetStdHandle"/> function.
        /// This function is primarily used by graphical user interface (GUI) application to create a console window.
        /// GUI applications are initialized without a console.
        /// Console applications are initialized with a console, unless they are created as detached processes
        /// (by calling the <see cref="CreateProcess"/> function with the <see cref="DETACHED_PROCESS"/> flag).
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "AllocConsole", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL AllocConsole();

        /// <summary>
        /// <para>
        /// Attaches the calling process to the console of the specified process.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/attachconsole"/>
        /// </para>
        /// </summary>
        /// <param name="dwProcessId">
        /// The identifier of the process whose console is to be used. This parameter can be one of the following values.
        /// pid	: Use the console of the specified process.
        /// <see cref="ATTACH_PARENT_PROCESS"/> : Use the console of the parent of the current process.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see langword="true"/>.
        /// If the function fails, the return value is <see langword="false"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A process can be attached to at most one console.
        /// If the calling process is already attached to a console, the error code returned is <see cref="ERROR_ACCESS_DENIED"/>.
        /// If the specified process does not have a console, the error code returned is <see cref="ERROR_INVALID_HANDLE"/>.
        /// If the specified process does not exist, the error code returned is <see cref="ERROR_INVALID_PARAMETER"/>.
        /// A process can use the <see cref="FreeConsole"/> function to detach itself from its console.
        /// If other processes share the console, the console is not destroyed, but the process that called <see cref="FreeConsole"/> cannot refer to it.
        /// A console is closed when the last process attached to it terminates or calls <see cref="FreeConsole"/>.
        /// After a process calls <see cref="FreeConsole"/>, it can call the <see cref="AllocConsole"/> function to create a new console
        /// or <see cref="AttachConsole"/> to attach to another console.
        /// To compile an application that uses this function, define _WIN32_WINNT as 0x0501 or later.
        /// For more information, see Using the Windows Headers.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "AttachConsole", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL AttachConsole([In] DWORD dwProcessId);

        /// <summary>
        /// <para>
        /// Creates a console screen buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/createconsolescreenbuffer"/>
        /// </para>
        /// </summary>
        /// <param name="dwDesiredAccess">
        /// The access to the console screen buffer.
        /// For a list of access rights, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="dwShareMode">
        /// This parameter can be zero, indicating that the buffer cannot be shared, or it can be one or more of the following values.
        /// <see cref="FILE_SHARE_READ"/>: Other open operations can be performed on the console screen buffer for read access.
        /// <see cref="FILE_SHARE_READ"/>: Other open operations can be performed on the console screen buffer for write access.
        /// </param>
        /// <param name="lpSecurityAttributes">
        /// A pointer to a <see cref="SECURITY_ATTRIBUTES"/> structure that determines whether the returned handle can be inherited by child processes.
        /// If <paramref name="lpSecurityAttributes"/> is <see cref="NullRef{SECURITY_ATTRIBUTES}"/>, the handle cannot be inherited.
        /// The <see cref="SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure
        /// specifies a security descriptor for the new console screen buffer.
        /// If <paramref name="lpSecurityAttributes"/> is <see cref="NullRef{SECURITY_ATTRIBUTES}"/>,
        /// the console screen buffer gets a default security descriptor.
        /// The ACLs in the default security descriptor for a console screen buffer come from the primary or impersonation token of the creator.
        /// </param>
        /// <param name="dwFlags">
        /// The type of console screen buffer to create.
        /// The only supported screen buffer type is <see cref="CONSOLE_TEXTMODE_BUFFER"/>.
        /// </param>
        /// <param name="lpScreenBufferData">
        /// Reserved; should be <see cref="NULL"/>.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is a handle to the new console screen buffer.
        /// If the function fails, the return value is <see cref="INVALID_HANDLE_VALUE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A console can have multiple screen buffers but only one active screen buffer.
        /// Inactive screen buffers can be accessed for reading and writing, but only the active screen buffer is displayed.
        /// To make the new screen buffer the active screen buffer, use the <see cref="SetConsoleActiveScreenBuffer"/> function.
        /// The newly created screen buffer will copy some properties from the active screen buffer at the time that this function is called.
        /// The behavior is as follows:
        /// Font - copied from active screen buffer
        /// Display Window Size - copied from active screen buffer
        /// Buffer Size - matched to Display Window Size (NOT copied)
        /// Default Attributes (colors) - copied from active screen buffer
        /// Default Popup Attributes (colors) - copied from active screen buffer
        /// The calling process can use the returned handle in any function that requires a handle to a console screen buffer,
        /// subject to the limitations of access specified by the <paramref name="dwDesiredAccess"/> parameter.
        /// The calling process can use the <see cref="DuplicateHandle"/> function to create a duplicate screen buffer handle
        /// that has different access or inheritability from the original handle.
        /// However, <see cref="DuplicateHandle"/> cannot be used to create a duplicate
        /// that is valid for a different process (except through inheritance).
        /// To close the console screen buffer handle, use the <see cref="CloseHandle"/> function.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "CreateConsoleScreenBuffer", ExactSpelling = true, SetLastError = true)]
        public static extern HANDLE CreateConsoleScreenBuffer([In] ACCESS_MASK dwDesiredAccess, [In] FileShareModes dwShareMode,
            [In] in SECURITY_ATTRIBUTES lpSecurityAttributes, [In] DWORD dwFlags, [In] LPVOID lpScreenBufferData);

        /// <summary>
        /// <para>
        /// Flushes the console input buffer. All input records currently in the input buffer are discarded.
        /// </para>
        /// <para>
        /// From:https://docs.microsoft.com/zh-cn/windows/console/flushconsoleinputbuffer
        /// </para>
        /// </summary>
        /// <param name="hConsoleInput">
        /// A handle to the console input buffer.
        /// The handle must have the <see cref="GENERIC_WRITE"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "FlushConsoleInputBuffer", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL FlushConsoleInputBuffer([In] HANDLE hConsoleInput);

        /// <summary>
        /// <para>
        /// Detaches the calling process from its console.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/freeconsole"/>
        /// </para>
        /// </summary>
        /// <returns>
        /// If the function succeeds, the return value is <see langword="true"/>.
        /// If the function fails, the return value is <see langword="false"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A process can be attached to at most one console.
        /// If the calling process is not already attached to a console, the error code returned is <see cref="ERROR_INVALID_PARAMETER"/>.
        /// A process can use the <see cref="FreeConsole"/> function to detach itself from its console.
        /// If other processes share the console, the console is not destroyed, but the process that called <see cref="FreeConsole"/> cannot refer to it.
        /// A console is closed when the last process attached to it terminates or calls <see cref="FreeConsole"/>.
        /// After a process calls <see cref="FreeConsole"/>, it can call the <see cref="AllocConsole"/> function to create a new console
        /// or <see cref="AttachConsole"/> to attach to another console.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "FreeConsole", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL FreeConsole();

        /// <summary>
        /// <para>
        /// Sends a specified signal to a console process group that shares the console associated with the calling process.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/generateconsolectrlevent"/>
        /// </para>
        /// </summary>
        /// <param name="dwCtrlEvent">
        /// The type of signal to be generated.
        /// This parameter can be one of the following values.
        /// <see cref="CTRL_C_EVENT"/>:
        /// Generates a CTRL+C signal.
        /// This signal cannot be generated for process groups.
        /// If <paramref name="dwProcessGroupId"/> is nonzero, this function will succeed,
        /// but the CTRL+C signal will not be received by processes within the specified process group.
        /// <see cref="CTRL_BREAK_EVENT"/>:
        /// Generates a CTRL+BREAK signal.
        /// </param>
        /// <param name="dwProcessGroupId">
        /// The identifier of the process group to receive the signal.
        /// A process group is created when the <see cref="CREATE_NEW_PROCESS_GROUP"/> flag is specified
        /// in a call to the <see cref="CreateProcess"/> function.
        /// The process identifier of the new process is also the process group identifier of a new process group.
        /// The process group includes all processes that are descendants of the root process.
        /// Only those processes in the group that share the same console as the calling process receive the signal.
        /// In other words, if a process in the group creates a new console, that process does not receive the signal, nor do its descendants.
        /// If this parameter is zero, the signal is generated in all processes that share the console of the calling process.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see langword="true"/>.
        /// If the function fails, the return value is <see langword="false"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// <see cref="GenerateConsoleCtrlEvent"/> causes the control handler functions of processes in the target group to be called.
        /// All console processes have a default handler function that calls the <see cref="ExitProcess"/> function.
        /// A console process can use the <see cref="SetConsoleCtrlHandler"/> function to install or remove other handler functions.
        /// <see cref="SetConsoleCtrlHandler"/> can also enable an inheritable attribute that causes the calling process to ignore CTRL+C signals.
        /// If <see cref="GenerateConsoleCtrlEvent"/> sends a CTRL+C signal to a process for which this attribute is enabled,
        /// the handler functions for that process are not called.
        /// CTRL+BREAK signals always cause the handler functions to be called.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GenerateConsoleCtrlEvent", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL GenerateConsoleCtrlEvent([In] CtrlEventFlags dwCtrlEvent, [In] DWORD dwProcessGroupId);

        /// <summary>
        /// <para>
        /// Retrieves the input code page used by the console associated with the calling process.
        /// A console uses its input code page to translate keyboard input into the corresponding character value.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getconsolecp"/>
        /// </para>
        /// </summary>
        /// <returns>
        /// The return value is a code that identifies the code page. For a list of identifiers, see Code Page Identifiers.
        /// If the return value is zero, the function has failed.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A code page maps 256 character codes to individual characters.
        /// Different code pages include different special characters, typically customized for a language or a group of languages.
        /// To retrieve more information about a code page, including it's name, see the <see cref="GetCPInfoEx"/> function.
        /// To set a console's input code page, use the <see cref="SetConsoleCP"/> function.
        /// To set and query a console's output code page, use the <see cref="SetConsoleOutputCP"/> and <see cref="GetConsoleOutputCP"/> functions.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetConsoleCP", ExactSpelling = true, SetLastError = true)]
        public static extern UINT GetConsoleCP();

        /// <summary>
        /// <para>
        /// Retrieves information about the size and visibility of the cursor for the specified console screen buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getconsolecursorinfo"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpConsoleCursorInfo">
        /// A pointer to a <see cref="CONSOLE_CURSOR_INFO"/> structure that receives information about the console's cursor.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetConsoleCursorInfo", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL GetConsoleCursorInfo([In] HANDLE hConsoleOutput, [Out] out CONSOLE_CURSOR_INFO lpConsoleCursorInfo);

        /// <summary>
        /// <para>
        /// Retrieves the current input mode of a console's input buffer or the current output mode of a console screen buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getconsolemode"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleHandle">
        /// A handle to the console input buffer or the console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpMode">
        /// A pointer to a variable that receives the current mode of the specified buffer.
        /// If the <paramref name="hConsoleHandle"/> parameter is an input handle, the mode can be one or more of the following values.
        /// When a console is created, all input modes except <see cref="ENABLE_WINDOW_INPUT"/> are enabled by default.
        /// <see cref="ENABLE_ECHO_INPUT"/>, <see cref="ENABLE_INSERT_MODE"/>, <see cref="ENABLE_LINE_INPUT"/>,
        /// <see cref="ENABLE_MOUSE_INPUT"/>,<see cref="ENABLE_PROCESSED_INPUT"/>, <see cref="ENABLE_QUICK_EDIT_MODE"/>,
        /// <see cref="ENABLE_WINDOW_INPUT"/>, <see cref="ENABLE_VIRTUAL_TERMINAL_INPUT"/>
        /// If the <paramref name="hConsoleHandle"/> parameter is a screen buffer handle, the mode can be one or more of the following values.
        /// When a screen buffer is created, both output modes are enabled by default.
        /// <see cref="ENABLE_PROCESSED_OUTPUT"/>, <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/>, <see cref="ENABLE_VIRTUAL_TERMINAL_PROCESSING"/>,
        /// <see cref="DISABLE_NEWLINE_AUTO_RETURN"/>, <see cref="ENABLE_LVB_GRID_WORLDWIDE"/>
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A console consists of an input buffer and one or more screen buffers.
        /// The mode of a console buffer determines how the console behaves during input or output (I/O) operations.
        /// One set of flag constants is used with input handles, and another set is used with screen buffer (output) handles.
        /// Setting the output modes of one screen buffer does not affect the output modes of other screen buffers.
        /// The <see cref="ENABLE_LINE_INPUT"/> and <see cref="ENABLE_ECHO_INPUT"/> modes only affect processes
        /// that use <see cref="ReadFile"/> or <see cref="ReadConsole"/> to read from the console's input buffer.
        /// Similarly, the <see cref="ENABLE_PROCESSED_INPUT"/> mode primarily affects <see cref="ReadFile"/> and <see cref="ReadConsole"/> users,
        /// except that it also determines whether CTRL+C input is reported in the input buffer (to be read by the <see cref="ReadConsoleInput"/> function)
        /// or is passed to a function defined by the application.
        /// The <see cref="ENABLE_WINDOW_INPUT"/> and <see cref="ENABLE_MOUSE_INPUT"/> modes determine
        /// whether user interactions involving window resizing and mouse actions are reported in the input buffer or discarded.
        /// These events can be read by <see cref="ReadConsoleInput"/>, but they are always filtered by <see cref="ReadFile"/> and <see cref="ReadConsole"/>.
        /// The <see cref="ENABLE_PROCESSED_OUTPUT"/> and <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/> modes only affect
        /// processes using <see cref="ReadFile"/> or <see cref="ReadConsole"/> and <see cref="WriteFile"/> or <see cref="WriteConsole"/>.
        /// To change a console's I/O modes, call <see cref="SetConsoleMode"/> function.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetConsoleMode", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL GetConsoleMode([In] HANDLE hConsoleHandle, [Out] out ConsoleModes lpMode);

        /// <summary>
        /// <para>
        /// Retrieves the output code page used by the console associated with the calling process.
        /// A console uses its output code page to translate the character values written
        /// by the various output functions into the images displayed in the console window.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getconsoleoutputcp"/>
        /// </para>
        /// </summary>
        /// <returns>
        /// The return value is a code that identifies the code page.
        /// For a list of identifiers, see Code Page Identifiers.
        /// If the return value is zero, the function has failed.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A code page maps 256 character codes to individual characters.
        /// Different code pages include different special characters, typically customized for a language or a group of languages.
        /// To retrieve more information about a code page, including it's name, see the <see cref="GetCPInfoEx"/> function.
        /// To set a console's output code page, use the <see cref="SetConsoleOutputCP"/> function.
        /// To set and query a console's input code page, use the <see cref="SetConsoleCP"/> and <see cref="GetConsoleCP"/> functions.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetConsoleOutputCP", ExactSpelling = true, SetLastError = true)]
        public static extern UINT GetConsoleOutputCP();

        /// <summary>
        /// <para>
        /// Retrieves information about the specified console screen buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getconsolescreenbufferinfo"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpConsoleScreenBufferInfo">
        /// A pointer to a <see cref="CONSOLE_SCREEN_BUFFER_INFO"/> structure that receives the console screen buffer information.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see langword="true"/>.
        /// If the function fails, the return value is <see langword="false"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The rectangle returned in the <see cref="CONSOLE_SCREEN_BUFFER_INFO.srWindow"/> member of the <see cref="CONSOLE_SCREEN_BUFFER_INFO"/> structure
        /// can be modified and then passed to the <see cref="SetConsoleWindowInfo"/> function to scroll the console screen buffer in the window,
        /// to change the size of the window, or both.
        /// All coordinates returned in the <see cref="CONSOLE_SCREEN_BUFFER_INFO"/> structure are in character-cell coordinates,
        /// where the origin (0, 0) is at the upper-left corner of the console screen buffer.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GenerateConsoleCtrlEvent", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL GetConsoleScreenBufferInfo([In] HANDLE hConsoleOutput, [Out] out CONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        /// <summary>
        /// <para>
        /// Retrieves the size of the largest possible console window, based on the current font and the size of the display.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getlargestconsolewindowsize"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is a <see cref="COORD"/> structure that specifies the number
        /// of character cell columns (<see cref="COORD.X"/> member) and rows (<see cref="COORD.Y"/> member) in the largest possible console window.
        /// Otherwise, the members of the structure are zero.
        /// o get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The function does not take into consideration the size of the console screen buffer,
        /// which means that the window size returned may be larger than the size of the console screen buffer.
        /// The <see cref="GetConsoleScreenBufferInfo"/> function can be used to determine the maximum size of the console window,
        /// given the current screen buffer size, the current font, and the display size.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetLargestConsoleWindowSize", ExactSpelling = true, SetLastError = true)]
        public static extern COORD GetLargestConsoleWindowSize([In] HANDLE hConsoleOutput);

        /// <summary>
        /// <para>
        /// Retrieves the number of unread input records in the console's input buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getnumberofconsoleinputevents"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleInput">
        /// A handle to the console input buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpcNumberOfEvents">
        /// A pointer to a variable that receives the number of unread input records in the console's input buffer.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The <see cref="GetNumberOfConsoleInputEvents"/> function reports the total number of unread input records in the input buffer,
        /// including keyboard, mouse, and window-resizing input records.
        /// Processes using the <see cref="ReadFile"/> or ReadConsole function can only read keyboard input.
        /// Processes using the <see cref="ReadConsoleInput"/> function can read all types of input records.
        /// A process can specify a console input buffer handle in one of the wait functions to determine when there is unread console input.
        /// When the input buffer is not empty, the state of a console input buffer handle is signaled.
        /// To read input records from a console input buffer without affecting the number of unread records,
        /// use the <see cref="PeekConsoleInput"/> function.
        /// To discard all unread records in a console's input buffer, use the <see cref="FlushConsoleInputBuffer"/> function.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetNumberOfConsoleInputEvents", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL GetNumberOfConsoleInputEvents([In] HANDLE hConsoleInput, [Out] out DWORD lpcNumberOfEvents);

        /// <summary>
        /// <para>
        /// Retrieves a handle to the specified standard device (standard input, standard output, or standard error).
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/getstdhandle"/>
        /// </para>
        /// </summary>
        /// <param name="nStdHandle">
        /// The standard device. This parameter can be one of the following values.
        /// <see cref="STD_INPUT_HANDLE"/>: The standard input device. Initially, this is the console input buffer, CONIN$.
        /// <see cref="STD_OUTPUT_HANDLE"/>: The standard output device. Initially, this is the active console screen buffer, CONOUT$.
        /// <see cref="STD_ERROR_HANDLE"/>: The standard error device. Initially, this is the active console screen buffer, CONOUT$.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is a handle to the specified device,
        /// or a redirected handle set by a previous call to <see cref="SetStdHandle"/>.
        /// The handle has <see cref="GENERIC_READ"/> and <see cref="GENERIC_WRITE"/> access rights,
        /// unless the application has used <see cref="SetStdHandle"/> to set a standard handle with lesser access.
        /// If the function fails, the return value is <see cref="INVALID_HANDLE_VALUE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// If an application does not have associated standard handles, such as a service running on an interactive desktop,
        /// and has not redirected them, the return value is <see cref="IntPtr.Zero"/>.
        /// </returns>
        /// <remarks>
        /// Handles returned by <see cref="GetStdHandle"/> can be used by applications that need to read from or write to the console.
        /// When a console is created, the standard input handle is a handle to the console's input buffer,
        /// and the standard output and standard error handles are handles of the console's active screen buffer.
        /// These handles can be used by the <see cref="ReadFile"/> and <see cref="WriteFile"/> functions,
        /// or by any of the console functions that access the console input buffer or a screen buffer
        /// (for example, the <see cref="ReadConsoleInput"/>, <see cref="WriteConsole"/>, or <see cref="GetConsoleScreenBufferInfo"/> functions).
        /// The standard handles of a process may be redirected by a call to <see cref="SetStdHandle"/>,
        /// in which case <see cref="GetStdHandle"/> returns the redirected handle.
        /// If the standard handles have been redirected, you can specify the CONIN$ value in a call to the <see cref="CreateFile"/> function
        /// to get a handle to a console's input buffer.
        /// Similarly, you can specify the CONOUT$ value to get a handle to a console's active screen buffer.
        /// Attach/detach behavior
        /// When attaching to a new console, standard handles are always replaced with console handles
        /// unless <see cref="STARTF_USESTDHANDLES"/> was specified during process creation.
        /// If the existing value of the standard handle is <see cref="IntPtr.Zero"/>, or the existing value of the standard handle
        /// looks like a console pseudohandle, the handle is replaced with a console handle.
        /// When a parent uses both <see cref="CREATE_NEW_CONSOLE"/> and <see cref="STARTF_USESTDHANDLES"/> to create a console process,
        /// standard handles will not be replaced unless the existing value of the standard handle is <see cref="IntPtr.Zero"/> or a console pseudohandle.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "GetStdHandle", ExactSpelling = true, SetLastError = true)]
        public static extern HANDLE GetStdHandle([In] DWORD nStdHandle);

        /// <summary>
        /// <para>
        /// Reads data from the specified console input buffer without removing it from the buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/peekconsoleinput"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleInput">
        /// A handle to the console input buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpBuffer">
        /// A pointer to an array of <see cref="INPUT_RECORD"/> structures that receives the input buffer data.
        /// </param>
        /// <param name="nLength">
        /// The size of the array pointed to by the <paramref name="lpBuffer"/> parameter, in array elements.
        /// </param>
        /// <param name="lpNumberOfEventsRead">
        /// A pointer to a variable that receives the number of input records read.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// If the number of records requested exceeds the number of records available in the buffer, the number available is read.
        /// If no data is available, the function returns immediately.
        /// This function uses either Unicode characters or 8-bit characters from the console's current code page.
        /// The console's code page defaults initially to the system's OEM code page.
        /// To change the console's code page, use the <see cref="SetConsoleCP"/> or <see cref="SetConsoleOutputCP"/> functions,
        /// or use the chcp or mode con cp select= commands.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "PeekConsoleInput", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL PeekConsoleInput([In] HANDLE hConsoleInput, [MarshalAs(UnmanagedType.LPArray)][In][Out] INPUT_RECORD[] lpBuffer,
            [In] DWORD nLength, [Out] out DWORD lpNumberOfEventsRead);

        /// <summary>
        /// <para>
        /// Reads character input from the console input buffer and removes it from the buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/readconsole"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleInput">
        /// A handle to the console input buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpBuffer">
        /// A pointer to a buffer that receives the data read from the console input buffer.
        /// </param>
        /// <param name="nNumberOfCharsToRead">
        /// The number of characters to be read.
        /// The size of the buffer pointed to by the <paramref name="lpBuffer"/> parameter should be
        /// at least <paramref name="nNumberOfCharsToRead"/> * sizeof(TCHAR) bytes.
        /// </param>
        /// <param name="lpNumberOfCharsRead">
        /// A pointer to a variable that receives the number of characters actually read.
        /// </param>
        /// <param name="pInputControl">
        /// A pointer to a <see cref="CONSOLE_READCONSOLE_CONTROL"/> structure that specifies a control character to signal the end of the read operation.
        /// This parameter can be <see cref="NullRef{CONSOLE_READCONSOLE_CONTROL}"/>.
        /// This parameter requires Unicode input by default.
        /// For ANSI mode, set this parameter to <see cref="NullRef{CONSOLE_READCONSOLE_CONTROL}"/>.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// <see cref="ReadConsole"/> reads keyboard input from a console's input buffer.
        /// It behaves like the <see cref="ReadFile"/> function, except that it can read in either Unicode (wide-character) or ANSI mode.
        /// To have applications that maintain a single set of sources compatible with both modes,
        /// use <see cref="ReadConsole"/> rather than <see cref="ReadFile"/>.
        /// Although <see cref="ReadConsole"/> can only be used with a console input buffer handle,
        /// <see cref="ReadFile"/> can be used with other handles (such as files or pipes).
        /// <see cref="ReadConsole"/> fails if used with a standard handle that has been redirected to be something other than a console handle.
        /// All of the input modes that affect the behavior of <see cref="ReadFile"/> have the same effect on <see cref="ReadConsole"/>.
        /// To retrieve and set the input modes of a console input buffer, use the <see cref="GetConsoleMode"/> and <see cref="SetConsoleMode"/> functions.
        /// If the input buffer contains input events other than keyboard events (such as mouse events or window-resizing events), they are discarded.
        /// Those events can only be read by using the <see cref="ReadConsoleInput"/> function.
        /// This function uses either Unicode characters or 8-bit characters from the console's current code page.
        /// The console's code page defaults initially to the system's OEM code page.
        /// To change the console's code page, use the <see cref="SetConsoleCP"/> or <see cref="SetConsoleOutputCP"/> functions,
        /// or use the chcp or mode con cp select= commands.
        /// The <paramref name="pInputControl"/> parameter can be used to enable intermediate wakeups
        /// from the read in response to a file-completion control character specified in a <see cref="CONSOLE_READCONSOLE_CONTROL"/> structure.
        /// This feature requires command extensions to be enabled, the standard output handle to be a console output handle, and input to be Unicode.
        /// Windows Server 2003 and Windows XP/2000: The intermediate read feature is not supported.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "ReadConsole", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL ReadConsole([In] HANDLE hConsoleInput, [Out] LPVOID lpBuffer, [In] DWORD nNumberOfCharsToRead,
            [Out] out DWORD lpNumberOfCharsRead, [In] in CONSOLE_READCONSOLE_CONTROL pInputControl);

        /// <summary>
        /// <para>
        /// Reads data from a console input buffer and removes it from the buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/readconsoleinput"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleInput">
        /// A handle to the console input buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpBuffer">
        /// A pointer to an array of <see cref="INPUT_RECORD"/> structures that receives the input buffer data.
        /// </param>
        /// <param name="nLength">
        /// The size of the array pointed to by the <paramref name="lpBuffer"/> parameter, in array elements.
        /// </param>
        /// <param name="lpNumberOfEventsRead">
        /// A pointer to a variable that receives the number of input records read.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// If the number of records requested in the <paramref name="nLength"/> parameter exceeds the number of records available in the buffer,
        /// the number available is read.
        /// The function does not return until at least one input record has been read.
        /// A process can specify a console input buffer handle in one of the wait functions to determine when there is unread console input.
        /// When the input buffer is not empty, the state of a console input buffer handle is signaled.
        /// To determine the number of unread input records in a console's input buffer, use the <see cref="GetNumberOfConsoleInputEvents"/> function.
        /// To read input records from a console input buffer without affecting the number of unread records,
        /// use the <see cref="PeekConsoleInput"/> function.
        /// To discard all unread records in a console's input buffer, use the <see cref="FlushConsoleInputBuffer"/> function.
        /// This function uses either Unicode characters or 8-bit characters from the console's current code page.
        /// The console's code page defaults initially to the system's OEM code page.
        /// To change the console's code page, use the <see cref="SetConsoleCP"/> or <see cref="SetConsoleOutputCP"/> functions,
        /// or use the chcp or mode con cp select= commands.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "ReadConsoleInput", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL ReadConsoleInput([In] HANDLE hConsoleInput, [Out] out INPUT_RECORD[] lpBuffer,
            [In] DWORD nLength, [Out] out DWORD lpNumberOfEventsRead);

        /// <summary>
        /// <para>
        /// Sets the input code page used by the console associated with the calling process.
        /// A console uses its input code page to translate keyboard input into the corresponding character value.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsolecp"/>
        /// </para>
        /// </summary>
        /// <param name="wCodePageID">
        /// The identifier of the code page to be set. For more information, see Remarks.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A code page maps 256 character codes to individual characters.
        /// Different code pages include different special characters, typically customized for a language or a group of languages.
        /// To find the code pages that are installed or supported by the operating system, use the <see cref="EnumSystemCodePages"/> function.
        /// The identifiers of the code pages available on the local computer are also stored in the registry under the following key:
        /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage
        /// However, it is better to use <see cref="EnumSystemCodePages"/> to enumerate code pages
        /// because the registry can differ in different versions of Windows.
        /// To determine whether a particular code page is valid, use the <see cref="IsValidCodePage"/> function.
        /// To retrieve more information about a code page, including its name, use the <see cref="GetCPInfoEx"/> function.
        /// For a list of available code page identifiers, see Code Page Identifiers.
        /// To determine a console's current input code page, use the <see cref="GetConsoleCP"/> function.
        /// To set and retrieve a console's output code page, use the <see cref="SetConsoleOutputCP"/> and <see cref="GetConsoleOutputCP"/> functions.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleCP", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleCP([In] UINT wCodePageID);

        /// <summary>
        /// <para>
        /// Adds or removes an application-defined HandlerRoutine function from the list of handler functions for the calling process.
        /// If no handler function is specified, the function sets an inheritable attribute
        /// that determines whether the calling process ignores CTRL+C signals.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsolectrlhandler"/>
        /// </para>
        /// </summary>
        /// <param name="HandlerRoutine">
        /// A pointer to the application-defined HandlerRoutine function to be added or removed.
        /// This parameter can be <see langword="null"/>.
        /// </param>
        /// <param name="Add">
        /// If this parameter is <see cref="TRUE"/>, the handler is added; if it is <see cref="FALSE"/>, the handler is removed.
        /// If the <paramref name="HandlerRoutine"/> parameter is <see langword="null"/>,
        /// a <see cref="TRUE"/> value causes the calling process to ignore CTRL+C input,
        /// and a <see cref="FALSE"/> value restores normal processing of CTRL+C input.
        /// This attribute of ignoring or processing CTRL+C is inherited by child processes.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// This function provides a similar notification for console application and services
        /// that <see cref="WM_QUERYENDSESSION"/> provides for graphical applications with a message pump.
        /// You could also use this function from a graphical application,
        /// but there is no guarantee it would arrive before the notification from <see cref="WM_QUERYENDSESSION"/>.
        /// Each console process has its own list of application-defined HandlerRoutine functions that handle CTRL+C and CTRL+BREAK signals.
        /// The handler functions also handle signals generated by the system when the user closes the console, logs off, or shuts down the system.
        /// Initially, the handler list for each process contains only a default handler function that calls the <see cref="ExitProcess"/> function.
        /// A console process adds or removes additional handler functions by calling the <see cref="SetConsoleCtrlHandler"/> function,
        /// which does not affect the list of handler functions for other processes.
        /// When a console process receives any of the control signals,
        /// its handler functions are called on a last-registered, first-called basis until one of the handlers returns <see cref="TRUE"/>.
        /// If none of the handlers returns <see cref="TRUE"/>, the default handler is called.
        /// For console processes, the CTRL+C and CTRL+BREAK key combinations are typically treated as signals
        /// (<see cref="CTRL_C_EVENT"/> and <see cref="CTRL_BREAK_EVENT"/>).
        /// When a console window with the keyboard focus receives CTRL+C or CTRL+BREAK,
        /// the signal is typically passed to all processes sharing that console.
        /// CTRL+BREAK is always treated as a signal, but typical CTRL+C behavior can be changed in three ways
        /// that prevent the handler functions from being called:
        /// The <see cref="SetConsoleMode"/> function can disable the <see cref="ENABLE_PROCESSED_INPUT"/> mode for a console's input buffer,
        /// so CTRL+C is reported as keyboard input rather than as a signal.
        /// Calling <see cref="SetConsoleCtrlHandler"/> with the <see langword="null"/> and <see cref="TRUE"/> arguments
        /// causes the calling process to ignore CTRL+C signals.
        /// This attribute is inherited by child processes, but it can be enabled or disabled by any process without affecting existing processes.
        /// If a console process is being debugged and CTRL+C signals have not been disabled,
        /// the system generates a <see cref="DBG_CONTROL_C"/> exception.
        /// This exception is raised only for the benefit of the debugger, and an application should never use an exception handler to deal with it.
        /// If the debugger handles the exception, an application will not notice the CTRL+C, with one exception: alertable waits will terminate.
        /// If the debugger passes the exception on unhandled, CTRL+C is passed to the console process and treated as a signal, as previously discussed.
        /// A console process can use the <see cref="GenerateConsoleCtrlEvent"/> function to send a CTRL+C or CTRL+BREAK signal to a console process group.
        /// The system generates <see cref="CTRL_CLOSE_EVENT"/>, <see cref="CTRL_LOGOFF_EVENT"/>, and <see cref="CTRL_SHUTDOWN_EVENT"/> signals
        /// when the user closes the console, logs off, or shuts down the system so that the process has an opportunity to clean up before termination.
        /// Console functions, or any C run-time functions that call console functions,
        /// may not work reliably during processing of any of the three signals mentioned previously.
        /// The reason is that some or all of the internal console cleanup routines may have been called before executing the process signal handler.
        /// Windows 7, Windows 8, Windows 8.1 and Windows 10:
        /// If a console application loads the gdi32.dll or user32.dll library,
        /// the HandlerRoutine function that you specify when you call <see cref="SetConsoleCtrlHandler"/> does not get called
        /// for the <see cref="CTRL_LOGOFF_EVENT"/> and <see cref="CTRL_SHUTDOWN_EVENT"/> events.
        /// The operating system recognizes processes that load gdi32.dll or user32.dll as Windows applications rather than console applications.
        /// This behavior also occurs for console applications that do not call functions in gdi32.dll or user32.dll directly,
        /// but do call functions such as Shell functions that do in turn call functions in gdi32.dll or user32.dll.
        /// To receive events when a user signs out or the device shuts down in these circumstances, create a hidden window in your console application,
        /// and then handle the <see cref="WM_QUERYENDSESSION"/> and <see cref="WM_ENDSESSION"/> window messages that the hidden window receives.
        /// You can create a hidden window by calling the <see cref="CreateWindowEx"/> method with the dwExStyle parameter set to 0.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleCtrlHandler", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleCtrlHandler([In] PHANDLER_ROUTINE HandlerRoutine, [In] BOOL Add);

        /// <summary>
        /// <para>
        /// Sets the cursor position in the specified console screen buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsolecursorposition"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="dwCursorPosition">
        /// A <see cref="COORD"/> structure that specifies the new cursor position, in characters.
        /// The coordinates are the column and row of a screen buffer character cell.
        /// The coordinates must be within the boundaries of the console screen buffer.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The cursor position determines where characters written by the <see cref="WriteFile"/> or <see cref="WriteConsole"/> function,
        /// or echoed by the <see cref="ReadFile"/> or <see cref="ReadConsole"/> function, are displayed.
        /// To determine the current position of the cursor, use the <see cref="GetConsoleScreenBufferInfo"/> function.
        /// If the new cursor position is not within the boundaries of the console screen buffer's window,
        /// the window origin changes to make the cursor visible.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleCursorPosition", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleCursorPosition([In] HANDLE hConsoleOutput, [In] COORD dwCursorPosition);

        /// <summary>
        /// <para>
        /// Sets the input mode of a console's input buffer or the output mode of a console screen buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsolemode"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleHandle">
        /// A handle to the console input buffer or a console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="dwMode">
        /// The input or output mode to be set.
        /// If the <paramref name="hConsoleHandle"/> parameter is an input handle, the mode can be one or more of the following values.
        /// When a console is created, all input modes except <see cref="ENABLE_WINDOW_INPUT"/> are enabled by default.
        /// <see cref="ENABLE_ECHO_INPUT"/>, <see cref="ENABLE_EXTENDED_FLAGS"/>, <see cref="ENABLE_INSERT_MODE"/>,
        /// <see cref="ENABLE_LINE_INPUT"/>, <see cref="ENABLE_MOUSE_INPUT"/>, <see cref="ENABLE_PROCESSED_INPUT"/>,
        /// <see cref="ENABLE_QUICK_EDIT_MODE"/>, <see cref="ENABLE_WINDOW_INPUT"/>, <see cref="ENABLE_VIRTUAL_TERMINAL_INPUT"/>
        /// If the <paramref name="hConsoleHandle"/> parameter is a screen buffer handle, the mode can be one or more of the following values.
        /// When a screen buffer is created, both output modes are enabled by default.
        /// <see cref="ENABLE_PROCESSED_OUTPUT"/>, <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/>, <see cref="ENABLE_VIRTUAL_TERMINAL_PROCESSING"/>,
        /// <see cref="DISABLE_NEWLINE_AUTO_RETURN"/>, <see cref="ENABLE_LVB_GRID_WORLDWIDE"/>
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A console consists of an input buffer and one or more screen buffers.
        /// The mode of a console buffer determines how the console behaves during input and output (I/O) operations.
        /// One set of flag constants is used with input handles, and another set is used with screen buffer (output) handles.
        /// Setting the output modes of one screen buffer does not affect the output modes of other screen buffers.
        /// The <see cref="ENABLE_LINE_INPUT"/> and <see cref="ENABLE_ECHO_INPUT"/> modes only affect processes
        /// that use <see cref="ReadFile"/> or <see cref="ReadConsole"/> to read from the console's input buffer.
        /// Similarly, the <see cref="ENABLE_PROCESSED_INPUT"/> mode primarily affects <see cref="ReadFile"/> and <see cref="ReadConsole"/> users,
        /// except that it also determines whether Ctrl+C input is reported in the input buffer (to be read by the <see cref="ReadConsoleInput"/> function)
        /// or is passed to a HandlerRoutine function defined by the application.
        /// The <see cref="ENABLE_WINDOW_INPUT"/> and <see cref="ENABLE_MOUSE_INPUT"/> modes determine whether user interactions
        /// involving window resizing and mouse actions are reported in the input buffer or discarded.
        /// These events can be read by <see cref="ReadConsoleInput"/>, but they are always filtered by <see cref="ReadFile"/> and <see cref="ReadConsole"/>.
        /// The <see cref="ENABLE_PROCESSED_OUTPUT"/> and <see cref="ENABLE_WRAP_AT_EOL_OUTPUT"/> modes only affect processes
        /// using <see cref="ReadFile"/> or <see cref="ReadConsole"/> and <see cref="WriteFile"/> or <see cref="WriteConsole"/>.
        /// To determine the current mode of a console input buffer or a screen buffer, use the <see cref="GetConsoleMode"/> function.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleMode", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleMode([In] HANDLE hConsoleHandle, [In] ConsoleModes dwMode);

        /// <summary>
        /// <para>
        /// Sets the output code page used by the console associated with the calling process.
        /// A console uses its output code page to translate the character values written 
        /// by the various output functions into the images displayed in the console window.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsoleoutputcp"/>
        /// </para>
        /// </summary>
        /// <param name="wCodePageID">
        /// The identifier of the code page to set. For more information, see Remarks.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// A code page maps 256 character codes to individual characters.
        /// Different code pages include different special characters, typically customized for a language or a group of languages.
        /// If the current font is a fixed-pitch Unicode font, <see cref="SetConsoleOutputCP"/> changes the mapping of the character values
        /// into the glyph set of the font, rather than loading a separate font each time it is called.
        /// This affects how extended characters (ASCII value greater than 127) are displayed in a console window.
        /// However, if the current font is a raster font, <see cref="SetConsoleOutputCP"/> does not affect how extended characters are displayed.
        /// To find the code pages that are installed or supported by the operating system, use the <see cref="EnumSystemCodePages"/> function.
        /// The identifiers of the code pages available on the local computer are also stored in the registry under the following key:
        /// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Nls\CodePage
        /// However, it is better to use <see cref="EnumSystemCodePages"/> to enumerate code pages
        /// because the registry can differ in different versions of Window.
        /// To determine whether a particular code page is valid, use the <see cref="IsValidCodePage"/> function.
        /// To retrieve more information about a code page, including its name, use the <see cref="GetCPInfoEx"/> function.
        /// For a list of available code page identifiers, see Code Page Identifiers.
        /// To determine a console's current output code page, use the <see cref="GetConsoleOutputCP"/> function.
        /// To set and retrieve a console's input code page, use the <see cref="SetConsoleCP"/> and <see cref="GetConsoleCP"/> functions.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleOutputCP", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleOutputCP([In] UINT wCodePageID);

        /// <summary>
        /// <para>
        /// Sets the attributes of characters written to the console screen buffer by the <see cref="WriteFile"/>
        /// or <see cref="WriteConsole"/> function, or echoed by the <see cref="ReadFile"/> or <see cref="ReadConsole"/> function.
        /// This function affects text written after the function call.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsoletextattribute"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="wAttributes">
        /// The character attributes.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// To determine the current color attributes of a screen buffer, call the <see cref="GetConsoleScreenBufferInfo"/> function.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleTextAttribute", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleTextAttribute([In] HANDLE hConsoleOutput, [In] ConsoleCharacterAttributes wAttributes);

        /// <summary>
        /// <para>
        /// Sets the current size and position of a console screen buffer's window.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setconsolewindowinfo"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_READ"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="bAbsolute">
        /// If this parameter is <see cref="TRUE"/>, the coordinates specify the new upper-left and lower-right corners of the window.
        /// If it is <see cref="FALSE"/>, the coordinates are relative to the current window-corner coordinates.
        /// </param>
        /// <param name="lpConsoleWindow">
        /// A pointer to a <see cref="SMALL_RECT"/> structure that specifies the new upper-left and lower-right corners of the window.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The function fails if the specified window rectangle extends beyond the boundaries of the console screen buffer.
        /// This means that the <see cref="SMALL_RECT.Top"/> and <see cref="SMALL_RECT.Left"/> members
        /// of the <paramref name="lpConsoleWindow"/> rectangle (or the calculated top and left coordinates,
        /// if <paramref name="bAbsolute"/> is <see cref="FALSE"/>) cannot be less than zero.
        /// Similarly, the <see cref="SMALL_RECT.Bottom"/> and <see cref="SMALL_RECT.Right"/> members
        /// (or the calculated bottom and right coordinates) cannot be greater than (screen buffer height – 1) and (screen buffer width – 1), respectively.
        /// The function also fails if the <see cref="SMALL_RECT.Right"/> member (or calculated right coordinate) is less than or equal
        /// to the <see cref="SMALL_RECT.Left"/> member (or calculated left coordinate) or
        /// if the <see cref="SMALL_RECT.Bottom"/> member (or calculated bottom coordinate) is less than or equal to
        /// the <see cref="SMALL_RECT.Top"/> member (or calculated top coordinate).
        /// For consoles with more than one screen buffer, changing the window location for one screen buffer
        /// does not affect the window locations of the other screen buffers.
        /// To determine the current size and position of a screen buffer's window, use the <see cref="GetConsoleScreenBufferInfo"/> function.
        /// This function also returns the maximum size of the window, given the current screen buffer size, the current font size, and the screen size. 
        /// The <see cref="GetLargestConsoleWindowSize"/> function returns the maximum window size given the current font and screen sizes,
        /// but it does not consider the size of the console screen buffer.
        /// <see cref="SetConsoleWindowInfo"/> can be used to scroll the contents of the console screen buffer
        /// by shifting the position of the window rectangle without changing its size.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetConsoleWindowInfo", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetConsoleWindowInfo([In] HANDLE hConsoleOutput, [In] BOOL bAbsolute, [In] in SMALL_RECT lpConsoleWindow);

        /// <summary>
        /// <para>
        /// Sets the handle for the specified standard device (standard input, standard output, or standard error).
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/setstdhandle"/>
        /// </para>
        /// </summary>
        /// <param name="nStdHandle">
        /// The standard device for which the handle is to be set. This parameter can be one of the following values.
        /// <see cref="STD_INPUT_HANDLE"/>: The standard input device.
        /// <see cref="STD_OUTPUT_HANDLE"/>: The standard output device.
        /// <see cref="STD_ERROR_HANDLE"/>: The standard error device.
        /// </param>
        /// <param name="hHandle">
        /// The handle for the standard device.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The standard handles of a process may have been redirected by a call to <see cref="SetStdHandle"/>,
        /// in which case <see cref="GetStdHandle"/> will return the redirected handle.
        /// If the standard handles have been redirected, you can specify the CONIN$ value
        /// in a call to the <see cref="CreateFile"/> function to get a handle to a console's input buffer.
        /// Similarly, you can specify the CONOUT$ value to get a handle to the console's active screen buffer.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "SetStdHandle", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL SetStdHandle([In] DWORD nStdHandle, [In] HANDLE hHandle);

        /// <summary>
        /// <para>
        /// Writes a character string to a console screen buffer beginning at the current cursor location.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/writeconsole"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_WRITE"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpBuffer">
        /// A pointer to a buffer that contains characters to be written to the console screen buffer.
        /// </param>
        /// <param name="nNumberOfCharsToWrite">
        /// The number of characters to be written.
        /// If the total size of the specified number of characters exceeds the available heap,
        /// the function fails with <see cref="ERROR_NOT_ENOUGH_MEMORY"/>.
        /// </param>
        /// <param name="lpNumberOfCharsWritten">
        /// A pointer to a variable that receives the number of characters actually written.
        /// </param>
        /// <param name="lpReserved">
        /// Reserved; must be <see cref="NULL"/>.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// The <see cref="WriteConsole"/> function writes characters to the console screen buffer at the current cursor position.
        /// The cursor position advances as characters are written.
        /// The <see cref="SetConsoleCursorPosition"/> function sets the current cursor position.
        /// Characters are written using the foreground and background color attributes associated with the console screen buffer.
        /// The <see cref="SetConsoleTextAttribute"/> function changes these colors.
        /// To determine the current color attributes and the current cursor position, use <see cref="GetConsoleScreenBufferInfo"/>.
        /// All of the input modes that affect the behavior of the <see cref="WriteFile"/> function have the same effect on <see cref="WriteConsole"/>.
        /// To retrieve and set the output modes of a console screen buffer, use the <see cref="GetConsoleMode"/> and <see cref="SetConsoleMode"/> functions.
        /// The <see cref="WriteConsole"/> function uses either Unicode characters or ANSI characters from the console's current code page.
        /// The console's code page defaults initially to the system's OEM code page.
        /// To change the console's code page, use the <see cref="SetConsoleCP"/> or <see cref="SetConsoleOutputCP"/> functions,
        /// or use the chcp or mode con cp select= commands.
        /// <see cref="WriteConsole"/> fails if it is used with a standard handle that is redirected to a file.
        /// If an application processes multilingual output that can be redirected, determine whether the output handle is a console handle
        /// (one method is to call the <see cref="GetConsoleMode"/> function and check whether it succeeds).
        /// If the handle is a console handle, call WriteConsole. If the handle is not a console handle,
        /// the output is redirected and you should call <see cref="WriteFile"/> to perform the I/O.
        /// Be sure to prefix a Unicode plain text file with a byte order mark.
        /// For more information, see Using Byte Order Marks.
        /// Although an application can use <see cref="WriteConsole"/> in ANSI mode to write ANSI characters, consoles do not support ANSI escape sequences.
        /// However, some functions provide equivalent functionality.
        /// For more information, see <see cref="SetCursorPos"/>, <see cref="SetConsoleTextAttribute"/>, and <see cref="GetConsoleCursorInfo"/>.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "WriteConsoleW", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL WriteConsole([In] HANDLE hConsoleOutput, [In] IntPtr lpBuffer, [In] DWORD nNumberOfCharsToWrite,
            [Out] out DWORD lpNumberOfCharsWritten, [In] LPVOID lpReserved);

        /// <summary>
        /// <para>
        /// Writes data directly to the console input buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleinput"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleInput">
        /// A handle to the console input buffer.
        /// The handle must have the <see cref="GENERIC_WRITE"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpBuffer">
        /// A pointer to an array of <see cref="INPUT_RECORD"/> structures that contain data to be written to the input buffer.
        /// </param>
        /// <param name="nLength">
        /// The number of input records to be written.
        /// </param>
        /// <param name="lpNumberOfEventsWritten">
        /// A pointer to a variable that receives the number of input records actually written.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// <see cref="WriteConsoleInput"/> places input records into the input buffer behind any pending events in the buffer.
        /// The input buffer grows dynamically, if necessary, to hold as many events as are written.
        /// This function uses either Unicode characters or 8-bit characters from the console's current code page.
        /// The console's code page defaults initially to the system's OEM code page.
        /// To change the console's code page, use the <see cref="SetConsoleCP"/> or <see cref="SetConsoleOutputCP"/> functions,
        /// or use the chcp or mode con cp select= commands.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "WriteConsoleInputW", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL WriteConsoleInput([In] HANDLE hConsoleInput, [MarshalAs(UnmanagedType.LPArray)][In] INPUT_RECORD[] lpBuffer,
            [In] DWORD nLength, [Out] out DWORD lpNumberOfEventsWritten);

        /// <summary>
        /// <para>
        /// Writes character and color attribute data to a specified rectangular block of character cells in a console screen buffer.
        /// The data to be written is taken from a correspondingly sized rectangular block at a specified location in the source buffer.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleoutput"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_WRITE"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpBuffer">
        /// The data to be written to the console screen buffer.
        /// This pointer is treated as the origin of a two-dimensional array of <see cref="CHAR_INFO"/> structures
        /// whose size is specified by the dwBufferSize parameter.
        /// </param>
        /// <param name="dwBufferSize">
        /// The size of the buffer pointed to by the lpBuffer parameter, in character cells.
        /// The <see cref="COORD.X"/> member of the <see cref="COORD"/> structure is the number of columns;
        /// the <see cref="COORD.Y"/> member is the number of rows.
        /// </param>
        /// <param name="dwBufferCoord">
        /// The coordinates of the upper-left cell in the buffer pointed to by the <paramref name="lpBuffer"/> parameter.
        /// The <see cref="COORD.X"/> member of the <see cref="COORD"/> structure is the column, and the <see cref="COORD.Y"/> member is the row.
        /// </param>
        /// <param name="lpWriteRegion">
        /// A pointer to a <see cref="SMALL_RECT"/> structure.
        /// On input, the structure members specify the upper-left and lower-right coordinates of the console screen buffer rectangle to write to.
        /// On output, the structure members specify the actual rectangle that was used.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// <see cref="WriteConsoleOutput"/> treats the source buffer and the destination screen buffer
        /// as two-dimensional arrays (columns and rows of character cells).
        /// The rectangle pointed to by the <paramref name="lpWriteRegion"/> parameter specifies the size and location of the block
        /// to be written to in the console screen buffer.
        /// A rectangle of the same size is located with its upper-left cell
        /// at the coordinates of the <paramref name="dwBufferCoord"/> parameter in the <paramref name="lpBuffer"/> array.
        /// Data from the cells that are in the intersection of this rectangle and the source buffer rectangle
        /// (whose dimensions are specified by the <paramref name="dwBufferSize"/> parameter) is written to the destination rectangle.
        /// Cells in the destination rectangle whose corresponding source location are outside
        /// the boundaries of the source buffer rectangle are left unaffected by the write operation.
        /// In other words, these are the cells for which no data is available to be written.
        /// Before <see cref="WriteConsoleOutput"/> returns, it sets the members of <paramref name="lpWriteRegion"/>
        /// to the actual screen buffer rectangle affected by the write operation.
        /// This rectangle reflects the cells in the destination rectangle for which there existed a corresponding cell in the source buffer,
        /// because <see cref="WriteConsoleOutput"/> clips the dimensions of the destination rectangle to the boundaries of the console screen buffer.
        /// If the rectangle specified by <paramref name="lpWriteRegion"/> lies completely outside the boundaries of the console screen buffer,
        /// or if the corresponding rectangle is positioned completely outside the boundaries of the source buffer, no data is written.
        /// In this case, the function returns with the members of the structure pointed to by the <paramref name="lpWriteRegion"/> parameter
        /// set such that the <see cref="SMALL_RECT.Right"/> member is less than the <see cref="SMALL_RECT.Left"/>,
        /// or the <see cref="SMALL_RECT.Bottom"/> member is less than the <see cref="SMALL_RECT.Top"/>.
        /// To determine the size of the console screen buffer, use the <see cref="GetConsoleScreenBufferInfo"/> function.
        /// <see cref="WriteConsoleOutput"/> has no effect on the cursor position.
        /// This function uses either Unicode characters or 8-bit characters from the console's current code page.
        /// The console's code page defaults initially to the system's OEM code page.
        /// To change the console's code page, use the <see cref="SetConsoleCP"/> or <see cref="SetConsoleOutputCP"/> functions,
        /// or use the chcp or mode con cp select= commands.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "WriteConsoleOutputW", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL WriteConsoleOutput([In] HANDLE hConsoleOutput, [In] CHAR_INFO[] lpBuffer, [In] COORD dwBufferSize,
            [In] COORD dwBufferCoord, [In] SMALL_RECT lpWriteRegion);

        /// <summary>
        /// <para>
        /// Copies a number of character attributes to consecutive cells of a console screen buffer, beginning at a specified location.
        /// </para>
        /// <para>
        /// From: <see href="https://docs.microsoft.com/zh-cn/windows/console/writeconsoleoutputattribute"/>
        /// </para>
        /// </summary>
        /// <param name="hConsoleOutput">
        /// A handle to the console screen buffer.
        /// The handle must have the <see cref="GENERIC_WRITE"/> access right.
        /// For more information, see Console Buffer Security and Access Rights.
        /// </param>
        /// <param name="lpAttribute">
        /// The attributes to be used when writing to the console screen buffer.
        /// For more information, see Character Attributes.
        /// </param>
        /// <param name="nLength">
        /// The number of screen buffer character cells to which the attributes will be copied.
        /// </param>
        /// <param name="dwWriteCoord">
        /// A <see cref="COORD"/> structure that specifies the character coordinates of the first cell in the console screen buffer
        /// to which the attributes will be written.
        /// </param>
        /// <param name="lpNumberOfAttrsWritten">
        /// A pointer to a variable that receives the number of attributes actually written to the console screen buffer.
        /// </param>
        /// <returns>
        /// If the function succeeds, the return value is <see cref="TRUE"/>.
        /// If the function fails, the return value is <see cref="FALSE"/>.
        /// To get extended error information, call <see cref="GetLastError"/>.
        /// </returns>
        /// <remarks>
        /// If the number of attributes to be written to extends beyond the end of the specified row in the console screen buffer,
        /// attributes are written to the next row.
        /// If the number of attributes to be written to extends beyond the end of the console screen buffer,
        /// the attributes are written up to the end of the console screen buffer.
        /// The character values at the positions written to are not changed.
        /// </remarks>
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode, EntryPoint = "WriteConsoleOutputAttributeW", ExactSpelling = true, SetLastError = true)]
        public static extern BOOL WriteConsoleOutputAttribute([In] HANDLE hConsoleOutput, [In] ConsoleCharacterAttributes[] lpAttribute,
            [In] COORD nLength, [In] COORD dwWriteCoord, [Out] out DWORD lpNumberOfAttrsWritten);
    }
}
